const { Client, LocalAuth, MessageMedia } = require("whatsapp-web.js");
const qrcode = require("qrcode-terminal");
const fs = require("fs");
const fsp = fs.promises;
const path = require("path");
const { pegarAleatoria } = require('./util/motivacional'); // Importa as frases
const mensagemBoasVindas = require('./util/bemvindos');
const { gerarMensagemContatos } = require('./util/contatosAdms');

const piadas = require("./util/piada");
const versiculos = require("./util/versiculos");
const { enviarAjuda } = require("./util/ajuda");
const { obterDicaAleatoria } = require('./util/dicas');
const formatarMinutosPagantes = require('./util/minutosPagantes');
const { brincadeiras, respostas } = require('./util/brincadeiras');
const { gerarSorteUnica } = require('./util/sorte');
const linksPorcentagem = require("./util/porcentagem");
const obterSaudacao = require("./util/saudacoes");
const mensagemPromocoes = require("./util/promocoes");
const { iniciarWatchParticipantes } = require("./watchParticipantes");
const { mensagemPlataformas, mensagemPlataformasParaDicas } = require('./util/plataformas');

const GRUPO_ALVO_ID = "120363417960334632@g.us";

const arquivoLista = path.join(__dirname, 'desafiolista.txt');
const PARTICIPANTES_PATH = path.join(__dirname, "participantes.json");
const participantesFormatadosPath = path.join(__dirname, "participantes_formatados.txt");
const dadosJogosPath = path.join(__dirname, "dados_jogos.json");

let dadosJogos = {};
let perguntaAtual = null;
let respondida = true;
let candidatoAcao = null;

iniciarWatchParticipantes();

// -------------------- FUNÃ‡Ã•ES AUXILIARES --------------------

async function carregarDadosJogos() {
  try {
    const rawData = await fsp.readFile(dadosJogosPath, "utf8");
    dadosJogos = JSON.parse(rawData);
    console.log("ğŸ“Š Dados dos jogos carregados com sucesso!");
  } catch (error) {
    console.error("âŒ Erro ao carregar dados_jogos.json:", error);
    console.log("O bot continuarÃ¡ funcionando, mas o comando !horarios pode nÃ£o funcionar corretamente.");
  }
}

async function carregarParticipantes() {
  try {
    const data = await fsp.readFile(PARTICIPANTES_PATH, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    if (err.code === 'ENOENT') {
      return [];
    }
    console.error("Erro ao carregar participantes:", err);
    return [];
  }
}

async function salvarParticipantes(participantes) {
  try {
    await fsp.writeFile(PARTICIPANTES_PATH, JSON.stringify(participantes, null, 2), 'utf8');
  } catch (err) {
    console.error("Erro ao salvar participantes:", err);
  }
}

async function enviarHorariosJogos(chat, horarioAlvo, horarioAtual) {
  if (!dadosJogos) {
    await chat.sendMessage("âŒ Dados dos jogos nÃ£o estÃ£o disponÃ­veis no momento.");
    return;
  }

  const jogosDaHora = dadosJogos[horarioAlvo];
  if (!jogosDaHora) {
    await chat.sendMessage(`ğŸ˜• Nenhum dado de horÃ¡rio encontrado para as ${horarioAlvo}.`);
    return;
  }

  const listaFormatada = Object.entries(jogosDaHora).map(([nome, minutos]) => ({
    nome,
    minutos,
  }));

  const mensagem = formatarMinutosPagantes(horarioAlvo, horarioAtual, listaFormatada);
  await chat.sendMessage(mensagem);
}


function iniciarVerificacaoAutomatica(client) {
  let ultimaHoraEnviadaPlataformas = null;
  const horariosEnviados = new Set();

  setInterval(async () => {
    const agora = new Date();
    const horaAtual = agora.getHours();

    if (horaAtual >= 7 && horaAtual <= 22) {
      if (agora.getMinutes() === 30 && horaAtual !== ultimaHoraEnviadaPlataformas) {
        try {
          const chat = await client.getChatById(GRUPO_ALVO_ID);
          await chat.sendMessage(mensagemPlataformas());
          console.log(`ğŸ“¢ Mensagem automÃ¡tica de plataformas enviada Ã s ${horaAtual}:30`);
          ultimaHoraEnviadaPlataformas = horaAtual;
        } catch (err) {
          console.error("Erro ao enviar mensagem automÃ¡tica das plataformas:", err);
        }
      }
    }
  }, 60 * 1000);

  setInterval(async () => {
    const agora = new Date();
    const horaAtual = agora.getHours();

    if (horaAtual < 7 || horaAtual >= 23) return;

    for (const horario of Object.keys(dadosJogos)) {
      const [hora, minuto] = horario.split(":").map(Number);
      let horarioJogo = new Date(agora);
      horarioJogo.setHours(hora, minuto, 0, 0);

      const horarioAlvo = new Date(horarioJogo.getTime() - 5 * 60000);

      if (agora >= horarioAlvo && agora < new Date(horarioAlvo.getTime() + 2 * 60000)) {
        if (!horariosEnviados.has(horario)) {
          try {
            const chat = await client.getChatById(GRUPO_ALVO_ID);
            const horaAtualFormatada = agora.toTimeString().slice(0, 5);
            await enviarHorariosJogos(chat, horario, horaAtualFormatada);
            console.log(`ğŸ“¢ Mensagem automÃ¡tica enviada 5 minutos antes de ${horario}`);
            horariosEnviados.add(horario);
          } catch (err) {
            console.error("Erro ao enviar mensagem automÃ¡tica:", err);
          }
        }
      } else {
        if (horariosEnviados.has(horario) && agora > horarioJogo) {
          horariosEnviados.delete(horario);
        }
      }
    }
  }, 60 * 1000);
}

function iniciarEnvioAutomaticoDicas(client) {
  let ultimoMinutoEnviado = null;

  setInterval(async () => {
    const agora = new Date();
    const minutos = agora.getMinutes();

    if (minutos % 40 === 0 && minutos !== ultimoMinutoEnviado) {
      if (agora.getHours() >= 7 && agora.getHours() <= 22) {
        try {
          const chat = await client.getChatById(GRUPO_ALVO_ID);
          const textoFixo = "ğŸ‘‘ *Dica da RAINHA DA SORTE* ğŸ‘‘\nAnote e use com sabedoria:";
          const mensagemCompleta = `${textoFixo}\n\n${obterDicaAleatoria()}\n\n${mensagemPlataformasParaDicas()}`;
          await chat.sendMessage(mensagemCompleta);
          console.log(`ğŸ“¢ Mensagem automÃ¡tica de dicas enviada Ã s ${agora.toTimeString().slice(0,5)}`);
          ultimoMinutoEnviado = minutos;
        } catch (err) {
          console.error("Erro ao enviar mensagem automÃ¡tica de dicas:", err);
        }
      }
    }
  }, 60 * 1000);
}

// -------------------- FUNÃ‡ÃƒO PARA TRATAR MENSAGENS --------------------

async function tratarMensagem(client, message) {
  const chat = await message.getChat();
  if (!message.body || typeof message.body !== "string") return;
  const corpo = message.body.toLowerCase().trim();
  const contact = await message.getContact();

  console.log("Mensagem recebida:", corpo);

  function isAdmin() {
    if (!chat.isGroup) return false;
    const autor = message.author || message.from;
    const participante = chat.participants.find(p => p.id._serialized === autor);
    return participante?.isAdmin || false;
  }

  if (corpo.startsWith('!expulsar')) {
    if (!chat.isGroup) return;

    if (!isAdmin()) {
      await chat.sendMessage('âŒ Apenas administradores podem usar este comando.');
      return;
    }

    const mentionedIds = message.mentionedIds;
    if (!mentionedIds || mentionedIds.length === 0) {
      await chat.sendMessage('âš ï¸ Por favor, mencione um usuÃ¡rio para expulsar.');
      return;
    }

    try {
      await chat.removeParticipants(mentionedIds);
      await chat.sendMessage('ğŸš· UsuÃ¡rio(s) expulso(s) com sucesso.');
    } catch (err) {
      console.error('Erro ao expulsar participante:', err);
      await chat.sendMessage('âŒ NÃ£o foi possÃ­vel expulsar o usuÃ¡rio. Verifique se o bot Ã© admin.');
    }
    return;
  }

  if (corpo === '!pergunta') {
    if (!chat.isGroup) return;
    if (!isAdmin()) {
      await chat.sendMessage('âŒ Apenas administradores podem usar este comando.');
      return;
    }
    if (!perguntaAtual || respondida) {
      const pergunta = brincadeiras[Math.floor(Math.random() * brincadeiras.length)];
      perguntaAtual = pergunta;
      respondida = false;
      candidatoAcao = null;
      await chat.sendMessage(`ğŸ§  Pergunta:\n\n${pergunta.pergunta}`);
    } else {
      await chat.sendMessage('âš ï¸ JÃ¡ hÃ¡ uma pergunta ativa no momento.');
    }
    return;
  }

if (corpo.startsWith('!parabenizar')) {
  if (!chat.isGroup) return; // sÃ³ funciona em grupos

  // Verifica se quem enviou Ã© admin
  if (!isAdmin()) {
    await chat.sendMessage('âŒ Apenas administradores podem usar este comando.');
    return;
  }

  // Pega os usuÃ¡rios mencionados na mensagem
  const mencionados = message.mentionedIds;

  if (!mencionados || mencionados.length === 0) {
    await chat.sendMessage('âš ï¸ Use: !parabenizar @usuario');
    return;
  }

  // Loop para parabenizar todos os usuÃ¡rios mencionados
  for (const userId of mencionados) {
    const contato = await client.getContactById(userId);

    await chat.sendMessage(
      `ğŸ‰ ParabÃ©ns, @${contato.id.user}! Procure a adm Ester ou a adm Kely para pegar sua banca! Lembrando: quem jogou nas nossas plataformas hoje ganha 15, esta semana 10.`,
      { mentions: [contato] }
    );
  }

  // Zera variÃ¡veis do jogo, se necessÃ¡rio
  respondida = true;
  perguntaAtual = null;

  return;
}

  if (perguntaAtual && respostas[perguntaAtual?.id] && !respondida) {
    const respostaEsperada = respostas[perguntaAtual.id].toLowerCase().trim();
    const corpoNormalizado = corpo.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\w\s]/gi, "").trim();
    const respostaNormalizada = respostaEsperada.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\w\s]/gi, "").trim();
    const autorId = message.author || message.from;

    if (perguntaAtual.id >= 51 && message.hasMedia && corpoNormalizado.includes(respostaNormalizada)) {
      candidatoAcao = autorId;
      await chat.sendMessage(`ğŸ“· Candidato @${autorId.split('@')[0]} enviou a resposta certa! ADM, confirme com !parabenizar @${autorId.split('@')[0]}`, { mentions: [await client.getContactById(autorId)] });
      return;
    }

    if (corpoNormalizado === respostaNormalizada) {
      respondida = true;
      perguntaAtual = null;

      const contato = await client.getContactById(autorId);
      const nome = contato.pushname || contato.number || "usuÃ¡rio";

      await chat.sendMessage(`ğŸ‰ ParabÃ©ns, @${contato.id.user}! Procure a adm Ester ou a adm Kely para pegar sua banca! Lembrando quem jogou nas nossas platafomas hoje, ganha banquinha de 15, quem jogou esta semana de 10`, { mentions: [contato] });
      return;
    }
  }

  if (corpo === "!cancelarpergunta") {
    if (!chat.isGroup) return;

    const remetente = message.author || message.from;
    const participante = chat.participants.find(p => p.id._serialized === remetente);

    if (!participante?.isAdmin && !participante?.isSuperAdmin) {
      await chat.sendMessage('âŒ Apenas administradores podem usar este comando.');
      return;
    }

    if (!perguntaAtual) {
      await chat.sendMessage('â„¹ï¸ NÃ£o hÃ¡ nenhuma pergunta ativa no momento.');
      return;
    }

    perguntaAtual = null;
    respondida = true;
    candidatoAcao = null;

    await chat.sendMessage('ğŸ›‘ A pergunta ativa foi cancelada pelo administrador.');
    return;
  }


  if (corpo === "!dica") {
    const textoFixo = "ğŸ‘‘ *Dica da RAINHA DA SORTE* ğŸ‘‘\nAnote e use com sabedoria:";
    const mensagemCompleta = `${textoFixo}\n\n${obterDicaAleatoria()}\n\n${mensagemPlataformasParaDicas()}`;
    await client.sendMessage(message.from, mensagemCompleta);
    return;
  }

if (corpo === "!motiva") {
  const frase = pegarAleatoria();
  await message.reply(`ğŸ’¡ Mensagem motivacional:\n\n${frase}`);
  return;
}

  if (chat.isGroup) {
    const autor = message.author || message.from;
    const participante = chat.participants.find(p => p.id._serialized === autor);
if (message.body && message.body.match(/https?:\/\/\S+/i)) {
  if (message.fromMe) return; // ignora mensagens do prÃ³prio bot

  const autor = message.author || message.from;
  const participante = chat.participants.find(p => p.id._serialized === autor);

  const ehAdmin = participante?.isAdmin || participante?.isSuperAdmin;

  if (!ehAdmin) {
    try {
      await message.delete(true);
      await chat.removeParticipants([autor]);
      console.log(`ğŸš« Link enviado por nÃ£o admin (${autor}) - removido.`);
      await chat.sendMessage('âŒ Link nÃ£o autorizado! Membro removido.');
    } catch (err) {
      console.error("Erro ao remover membro:", err);
      await chat.sendMessage("âš ï¸ NÃ£o foi possÃ­vel remover o membro. O bot precisa ser admin.");
    }
  } else {
    console.log(`ğŸ”‘ Link enviado por admin (${autor}) - permitido.`);
  }
  return;
}
  }

  if (corpo === "!ajuda" || corpo === "!comandos") {
    await enviarAjuda(chat);
    return;
  }
if (corpo === "!adms") {
  await chat.sendMessage(gerarMensagemContatos());
  return;
}


  if (/bo+m+ *di+a+/i.test(corpo) || /bo+a+ *ta+r+d+e+/i.test(corpo) || /bo+a+ *noi+t+e+/i.test(corpo)) {
    const saudacao = obterSaudacao(corpo);
    await message.reply(saudacao);
    return;
  }

  switch (corpo) {
    case "!links":
      await chat.sendMessage(linksPorcentagem);
      return;

    case "!sorte":
      await message.reply(gerarSorteUnica());
      return;

    case "!plataformas":
      await chat.sendMessage(mensagemPlataformas());
      return;

    case "!promo":
      await chat.sendMessage(mensagemPromocoes());
      return;

    case "!participantes":
      try {
        const conteudo = await fsp.readFile(participantesFormatadosPath, "utf8");
        const resposta = `ğŸ“‹ *Participantes confirmados para o sorteio do fim do mÃªs:*\n\n${conteudo}`;
        await chat.sendMessage(resposta);
      } catch (err) {
        console.error("âŒ Erro ao ler participantes_formatados.txt:", err);
        await chat.sendMessage("âš ï¸ Erro ao carregar a lista de participantes.");
      }
      return;

    case "!sortear2":
      const participantes = await carregarParticipantes();
      if (participantes.length < 2) {
        await chat.sendMessage("â— NÃ£o hÃ¡ participantes suficientes para realizar o sorteio de dois nomes.");
        return;
      }
      const embaralhados = participantes.sort(() => 0.5 - Math.random());
      const [sorteado1, sorteado2] = embaralhados;
      await chat.sendMessage(`ğŸ‰ Sorteio realizado!\n\nğŸ¥‡ *${sorteado1.nome}* (${sorteado1.numero} - ${sorteado1.plataforma})\nğŸ¥ˆ *${sorteado2.nome}* (${sorteado2.numero} - ${sorteado2.plataforma})\n\nParabÃ©ns aos vencedores! ğŸ€`);
      return;
  }

  if (corpo.startsWith("!biblia")) {
    const versiculoAleatorio = versiculos[Math.floor(Math.random() * versiculos.length)];
    await message.reply(`ğŸ“– VersÃ­culo do dia:\n\n${versiculoAleatorio}`);
    return;
  }

  if (corpo.startsWith("!desafio")) {
    const partes = message.body.trim().split(" ");
    if (partes.length < 3) {
      await chat.sendMessage("âš ï¸ Formato invÃ¡lido. Use: !desafio NomeDoDesafio Valor\nEx: !desafio Mega Sorteio R$ 50,00");
      return;
    }

    const valorRaw = partes.pop();
    const nomeDesafio = partes.slice(1).join(" ");
    const valorLimpo = valorRaw.replace("R$", "").replace(",", ".").trim();
    const valor = parseFloat(valorLimpo);

    if (isNaN(valor)) {
      await chat.sendMessage("âš ï¸ Valor invÃ¡lido. Use um valor monetÃ¡rio. Ex: R$ 50,00");
      return;
    }
    const valorFormatado = `R$ ${valor.toFixed(2).replace(".", ",")}`;
const data = new Date();
const linhaLista = `Nome: ${nomeDesafio} - Valor: ${valorFormatado} - Criado em: ${data.toISOString()}\n`;

try {
  await fs.appendFile(arquivoLista, linhaLista, "utf8");
  const mensagem = `ğŸ¯ *Desafio Criado!*\n\nğŸ“Œ Nome: *${nomeDesafio}*\nğŸ’¸ Valor: *${valorFormatado}*\n\nParticipe e mostre sua sorte!`;
  await chat.sendMessage(mensagem);
} catch (err) {
  console.error("Erro ao salvar desafio:", err);
  await chat.sendMessage("âŒ Ocorreu um erro ao salvar o desafio.");
}
    return;
  }

  if (corpo === "!curiosidade") {
  const piada = piadas[Math.floor(Math.random() * piadas.length)];

  const mensagemFormatada = `ğŸ˜‚ *JOGOS PARA O GRUPO* ğŸ˜‚

ğŸŒŸ _VocÃª conhece este jogo?_

ğŸ“Œ *${piada}*

*Volatilidade* significa a tendÃªncia de algo mudar rapidamente e de forma imprevisÃ­vel. 

ğŸ” Envie *!curiosidade* para receber outra!`;

  await chat.sendMessage(mensagemFormatada);
 }

  if (corpo.startsWith("!horarios")) {
    const partes = corpo.split(" ");
    if (partes.length < 2) {
      await chat.sendMessage("â— Use o comando assim: !horarios HH:mm");
      return;
    }
    const horario = partes[1];
    const regexHora = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!regexHora.test(horario)) {
      await chat.sendMessage("â— Formato invÃ¡lido! Use HH:mm (ex: 20:30).");
      return;
    }
    const horaAtual = new Date().toTimeString().slice(0, 5);
    await enviarHorariosJogos(chat, horario, horaAtual);
    return;
  }

  if (corpo.startsWith("!marcartodos")) {
  const textoOriginal = message.body.slice("!marcartodos".length).trim();
  const mensagemFormatada = textoOriginal.length > 0 
    ? textoOriginal 
    : "ğŸ“£ *Mensagem para todos.*";

  try {
    const mentions = chat.participants.map(p => p.id._serialized);
    await message.delete();
    await chat.sendMessage(mensagemFormatada, { mentions });
  } catch (err) {
    console.error("âŒ Erro ao processar !marcartodos:", err);
    await chat.sendMessage("âš ï¸ NÃ£o consegui marcar todos.");
  }
  return;
}

  }
 
 


// -------------------- INICIALIZAÃ‡ÃƒO --------------------

async function iniciar() {
  await carregarDadosJogos();


const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    executablePath: "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"
  }
});

  client.on("qr", (qr) => {
    qrcode.generate(qr, { small: true });
    console.log("ğŸ“² Escaneie o QR Code para conectar.");
  });

  client.on("ready", () => {
    console.log("âœ… Cliente estÃ¡ pronto!");
    iniciarVerificacaoAutomatica(client);
    iniciarEnvioAutomaticoDicas(client);
  });

  client.on("message", async (message) => {
    try {
      await tratarMensagem(client, message);
    } catch (err) {
      console.error("Erro no tratamento da mensagem:", err);
    }
  });

  // ğŸ“Œ AQUI entra o evento de boas-vindas
  client.on('group_join', async (notification) => {
    try {
      const chat = await notification.getChat();
      const contact = await notification.getContact();
      const nomeUsuario = contact.pushname || contact.number || "novo membro";

      const mensagem = mensagemBoasVindas(nomeUsuario, chat.name);

      await chat.sendMessage(mensagem, { mentions: [contact] });
      console.log(`ğŸ‘‘ Mensagem de boas-vindas enviada para ${nomeUsuario}`);
    } catch (err) {
      console.error("âŒ Erro ao enviar mensagem de boas-vindas:", err);
    }
  });

  await client.initialize();
}
iniciar();